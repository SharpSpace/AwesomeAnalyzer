# JJ0103
Use ValueTask instead of Task for better performance.

## Background
`ValueTask` and `ValueTask<T>` are value types introduced to reduce allocations when async methods complete synchronously or when results are cached. Unlike `Task`, which is a reference type and requires heap allocation, `ValueTask` can avoid allocations in common scenarios.

## When to use ValueTask
- Methods that frequently complete synchronously
- Methods that cache results
- High-performance scenarios where allocations matter
- Methods that are called frequently in hot paths

## When NOT to use ValueTask
- Methods implementing interfaces that specify `Task` (would break interface contract)
- Virtual or override methods (cannot change signature)
- Methods where the result is awaited multiple times
- Public API methods where backwards compatibility is required

## Violation
```csharp
using System.Threading.Tasks;

sealed class DataCache
{
    private string _cachedData;

    public async Task<string> GetDataAsync()
    {
        if (_cachedData != null)
        {
            return _cachedData;
        }
        
        await Task.Delay(100);
        _cachedData = "data";
        return _cachedData;
    }
}
```

## Fix
```csharp
using System.Threading.Tasks;

sealed class DataCache
{
    private string _cachedData;

    public async ValueTask<string> GetDataAsync()
    {
        if (_cachedData != null)
        {
            return _cachedData;
        }
        
        await Task.Delay(100);
        _cachedData = "data";
        return _cachedData;
    }
}
```

## Performance Impact
Using `ValueTask` can reduce allocations and improve performance in scenarios where:
- Methods complete synchronously most of the time
- Results are frequently cached
- Methods are called in tight loops or hot paths

Note: This is an informational diagnostic and should be applied judiciously based on actual performance requirements and measurements.
